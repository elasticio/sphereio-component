/* ===========================================================
# underscore-mixins - v0.1.4
# ==============================================================
# Copyright (c) 2015 Nicola Molinari
# Licensed MIT.
*/
var _;

_ = require('underscore');


/**
 * A collection of methods to be used as underscore mixins
 * @example
 *   _ = require 'underscore'
 *   _.mixin require('underscore-mixins')
 */

module.exports = {

  /**
   * Returns a deep clone of the given object
   * @param {Object} obj A JSON object
   * @return {Object} A deep clone of the given object
   */
  deepClone: function(obj) {
    if (!obj) {
      return {};
    }
    return JSON.parse(JSON.stringify(obj));
  },

  /**
   * Stringifies a JSON object in a pretty format.
   * In case of a non JSON object, the argument itself is returned (also for Error instances).
   * @param {Object} obj A JSON object
   * @param {Number} [indentation] The indentation number (default 2)
   * @return {String} A pretty string
   */
  prettify: function(obj, indentation) {
    if (indentation == null) {
      indentation = 2;
    }
    if (!obj) {
      return;
    }
    switch (false) {
      case !(obj instanceof Error):
        return obj;
      case !_.isObject(obj):
        return JSON.stringify(obj, null, indentation);
      default:
        return obj;
    }
  },

  /**
   * Returns the percentage of the given values
   * @param {Number} x The current number out of total
   * @param {Number} tot The total number to calculate the percentage
   * @return {Number} The percentage value, rounded
   */
  percentage: function(x, tot) {
    return Math.round(x * 100 / tot);
  },

  /**
   * Returns a URL query string from a key-value object
   * @param {Object} params A JSON object containing key-value query params
   * @return {String} A query string, or empty if params is undefined
   */
  stringifyQuery: function(params) {
    var query;
    if (!params) {
      return "";
    }
    query = _.reduce(params, function(memo, value, key) {
      _.each(_.flatten([value]), function(v) {
        return memo.push("" + key + "=" + v);
      });
      return memo;
    }, []);
    return query.join("&");
  },

  /**
   * Returns a key-value JSON object from a query string
   * @param {String} query A query string
   * @param {Boolean} hasUniqueParams Will determine the parsing strategy in case
   *                                  of multiple parameters with the same key (default 'true')
   *                                  - `true` (default): same parameter key will be overridden
   *                                  - `false`: same parameters values will be put in an array
   *                                  Example:
   *                                    query = 'foo=bar1&foo=bar2'
   *                                    # => {foo: ['bar1', 'bar2']}
   * @return {Object} A JSON object (note that all values are parsed as string)
   */
  parseQuery: function(query, hasUniqueParams) {
    if (hasUniqueParams == null) {
      hasUniqueParams = true;
    }
    if (!query) {
      return {};
    }
    return _.reduce(query.split('&'), function(memo, param) {
      var currentValue, key, splitted, value;
      splitted = param.split('=');
      if (_.size(splitted) < 2) {
        return memo;
      }
      key = splitted[0];
      value = param.replace("" + key + "=", '');
      if (_.has(memo, key) && !hasUniqueParams) {
        currentValue = memo[key];
        memo[key] = _.flatten([currentValue].concat(value));
      } else {
        memo[key] = value;
      }
      return memo;
    }, {});
  },

  /**
   * Transform a given list in a new nested list of single list elements (batches)
   * given max size.
   * Useful if you need to process some elements on a list, but not all together.
   * @param  {Array} list The original list
   * @param  {Int} size The size of the nested lists to group the elements to
   * @return {Array} A new list with nested batch lists of given size
   * @throws {Error} If size is not defined
   * @example
   *   list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
   *   console.log _.batchList(list, 3)
   *   # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0]]
   */
  batchList: function(list, size) {
    if (!size) {
      throw new Error('List batch size is required');
    }
    return list.reduce(function(batch, value, index) {
      if (index % size === 0) {
        batch.push([]);
      }
      batch[batch.length - 1].push(value);
      return batch;
    }, []);
  }
};
