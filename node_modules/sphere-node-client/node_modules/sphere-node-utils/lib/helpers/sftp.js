var Connection, Q, Sftp, uniqueId, _;

Q = require('q');

_ = require('underscore');

Connection = require('ssh2');

uniqueId = function(prefix) {
  return _.uniqueId("" + prefix + (new Date().getTime()) + "_");
};

Sftp = (function() {
  function Sftp(_options) {
    this._options = _options != null ? _options : {};
    this.logger = this._options.logger;
  }


  /**
   * Get directory entries.
   * @param {Object} sftp SFTP handle
   * @param {String} dirName Directory to get the entries from
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.listFiles = function(sftp, dirName) {
    var deferred;
    deferred = Q.defer();
    sftp.opendir(dirName, function(err, handle) {
      if (err) {
        return deferred.reject(err);
      } else {
        return sftp.readdir(handle, function(err, list) {
          if (err) {
            deferred.reject(err);
          } else {
            if (list === false) {
              deferred.resolve([]);
            } else {
              deferred.resolve(list);
            }
          }
          return sftp.close(handle);
        });
      }
    });
    return deferred.promise;
  };


  /**
   * {@link https://github.com/mscdex/ssh2#stats}
   * Get directory statistics (useful to check if file is directory or file)
   * @param {Object} sftp SFTP handle
   * @param {String} path Path to the file where to get the stats from
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.stats = function(sftp, path) {
    var d;
    d = Q.defer();
    sftp.stat(path, function(err, stats) {
      if (err) {
        return d.reject(err);
      } else {
        return d.resolve(stats);
      }
    });
    return d.promise;
  };

  Sftp.prototype.readFile = function(fileName) {};

  Sftp.prototype.saveFile = function(path, fileName, content) {};


  /**
   * Download a file.
   * @param {Object} sftp SFTP handle
   * @param {String} remotePath Path of the remote file
   * @param {String} localPath Download file to this path
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.getFile = function(sftp, remotePath, localPath) {
    var deferred;
    deferred = Q.defer();
    sftp.fastGet(remotePath, localPath, function(err) {
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve();
      }
    });
    return deferred.promise;
  };


  /**
   * Upload a file.
   * @param {Object} sftp SFTP handle
   * @param {String} localPath Upload file to this path
   * @param {String} remotePath Path of the remote file
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.putFile = function(sftp, localPath, remotePath) {
    var deferred;
    deferred = Q.defer();
    sftp.fastPut(localPath, remotePath, function(err) {
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve();
      }
    });
    return deferred.promise;
  };


  /**
   * Upload a file safely by temporarly upload it to a tmp folder, moving it then into the
   * given target path to assure that it's there.
   * @param {Object} sftp SFTP handle
   * @param {String} localPath Upload file to this path
   * @param {String} remotePath Path of the remote file
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.safePutFile = function(sftp, localPath, remotePath, forceOverwrite) {
    var canUpload, tmpName, _ref;
    if (forceOverwrite == null) {
      forceOverwrite = true;
    }
    tmpName = "" + remotePath + "_" + (uniqueId('tmp'));
    if ((_ref = this.logger) != null) {
      _ref.debug("About to upload file " + localPath);
    }
    canUpload = (function(_this) {
      return function(fileName) {
        var _ref1, _ref2;
        if (forceOverwrite) {
          if ((_ref1 = _this.logger) != null) {
            _ref1.debug('Force overwrite is true, proceed with upload');
          }
          return Q();
        } else {
          if ((_ref2 = _this.logger) != null) {
            _ref2.debug("Force overwrite is false, checking if " + fileName + " exists");
          }
          return _this.stats(sftp, fileName).then(function(stat) {
            var _ref3;
            if (stat.isFile()) {
              return Q.reject("Uploading file " + fileName + " already exists on the remote server and cannot proceed unless I'm being forced to");
            } else {
              if ((_ref3 = this.logger) != null) {
                _ref3.debug("File " + fileName + " doesn't appear to be a file, proceeding with upload");
              }
              return Q();
            }
          }).fail(function() {
            var _ref3;
            if ((_ref3 = _this.logger) != null) {
              _ref3.debug("File " + fileName + " not found, proceeding with upload");
            }
            return Q();
          });
        }
      };
    })(this);
    return canUpload(tmpName).then((function(_this) {
      return function() {
        return _this.putFile(sftp, localPath, tmpName);
      };
    })(this)).then((function(_this) {
      return function() {
        var _ref1;
        if ((_ref1 = _this.logger) != null) {
          _ref1.debug("File uploaded as " + tmpName);
        }
        return _this.stats(sftp, tmpName);
      };
    })(this)).then((function(_this) {
      return function(stat) {
        var _ref1, _ref2;
        if (stat.isFile()) {
          if ((_ref1 = _this.logger) != null) {
            _ref1.debug("File check successful, about to rename it");
          }
          return _this.safeRenameFile(sftp, tmpName, remotePath);
        } else {
          if ((_ref2 = _this.logger) != null) {
            _ref2.debug("File check failed, about to cleanup " + tmpName);
          }
          return _this.removeFile(sftp, tmpName).then(function() {
            return Q.reject('File upload check failed');
          });
        }
      };
    })(this));
  };


  /**
   * Rename a remote resource.
   * @param {Object} sftp SFTP handle
   * @param {String} srcPath Source path of the remote resource
   * @param {String} destPath Destination path of the remote resource
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.renameFile = function(sftp, srcPath, destPath) {
    var deferred;
    deferred = Q.defer();
    sftp.rename(srcPath, destPath, function(err) {
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve();
      }
    });
    return deferred.promise;
  };


  /**
   * Rename a remote resource safely, by checking if it's there first and remove it if so.
   * @param {Object} sftp SFTP handle
   * @param {String} srcPath Source path of the remote resource
   * @param {String} destPath Destination path of the remote resource
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.safeRenameFile = function(sftp, srcPath, destPath) {

    /* WORKAROUND
    Unfortunately, rename will fail if there is already an existing file with the same name.
    To avoid that, we should remove first the old file, then rename the new one
     */
    var _ref;
    if ((_ref = this.logger) != null) {
      _ref.debug("About to safe rename the file " + srcPath + " to " + destPath);
    }
    return this.stats(sftp, destPath).then((function(_this) {
      return function(stat) {
        var _ref1;
        if ((_ref1 = _this.logger) != null) {
          _ref1.debug("File " + destPath + " already exist, about to remove it before rename it");
        }
        if (stat.isFile()) {
          return _this.removeFile(sftp, destPath).then(function() {
            var _ref2;
            if ((_ref2 = _this.logger) != null) {
              _ref2.debug("File " + destPath + " removed, about to rename it");
            }
            return _this.renameFile(sftp, srcPath, destPath).then(function() {
              return Q();
            }).fail(function(err) {
              return Q.reject(err);
            });
          }).fail(function(err) {
            var _ref2;
            if ((_ref2 = _this.logger) != null) {
              _ref2.debug("Failed to remove file " + destPath + " during safeRename");
            }
            return Q.reject(err);
          });
        } else {
          return Q.reject("The resource at " + destPath + " already exist and it doesn't appear to be a file. Please check that what you want to rename is a file.");
        }
      };
    })(this)).fail((function(_this) {
      return function() {
        return _this.renameFile(sftp, srcPath, destPath);
      };
    })(this));
  };


  /**
   * Remove remote file
   * @param {Object} sftp SFTP handle
   * @param {String} path Path to the remote file
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.removeFile = function(sftp, path) {
    var deferred;
    deferred = Q.defer();
    sftp.unlink(path, function(err) {
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve();
      }
    });
    return deferred.promise;
  };


  /**
   * Starts a SFTP session.
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.openSftp = function() {
    var connectOpts, deferred;
    deferred = Q.defer();
    this.conn = new Connection();
    this.conn.on('ready', (function(_this) {
      return function() {
        var _ref;
        if ((_ref = _this.logger) != null) {
          _ref.debug('Connection :: ready');
        }
        return _this.conn.sftp(function(err, sftp) {
          if (err) {
            return deferred.reject(err);
          } else {
            sftp.on('end', function() {
              var _ref1;
              return (_ref1 = _this.logger) != null ? _ref1.debug('SFTP :: end') : void 0;
            });
            return deferred.resolve(sftp);
          }
        });
      };
    })(this));
    this.conn.on('error', (function(_this) {
      return function(err) {
        var _ref;
        if ((_ref = _this.logger) != null) {
          _ref.debug(err, 'Connection :: error');
        }
        return deferred.reject(err);
      };
    })(this));
    this.conn.on('close', (function(_this) {
      return function(hadError) {
        var _ref;
        if ((_ref = _this.logger) != null) {
          _ref.debug("Connection :: close - had error: " + hadError);
        }
        if (hadError) {
          return deferred.reject('Error on closing SFTP connection');
        }
      };
    })(this));
    this.conn.on('end', (function(_this) {
      return function() {
        var _ref;
        return (_ref = _this.logger) != null ? _ref.debug('Connection :: end') : void 0;
      };
    })(this));
    connectOpts = {
      host: this._options.host,
      username: this._options.username,
      password: this._options.password
    };
    if (this._options.debug) {
      connectOpts['debug'] = (function(_this) {
        return function(msg) {
          var _ref;
          return (_ref = _this.logger) != null ? _ref.debug(msg) : void 0;
        };
      })(this);
    }
    this.conn.connect(connectOpts);
    return deferred.promise;
  };


  /**
   * Close SFTP session and underlying connection.
   * @param {Object} sftp SFTP handle
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.close = function(sftp) {
    if (sftp) {
      sftp.end();
    }
    return this.conn.end();
  };


  /**
   * Download all files from a given remote folder (exclude '.', '..' and directories)
   * @param {Object} sftp SFTP handle
   * @param {String} tmpFolder Local tmp folder path where to save the files to
   * @param {String} remoteFolder Remote path folder where to download the files from
   * @param {String} [fileRegex] A RegExp to be applied when filtering files
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.downloadAllFiles = function(sftp, tmpFolder, remoteFolder, fileRegex) {
    var deferred;
    if (fileRegex == null) {
      fileRegex = '';
    }
    deferred = Q.defer();
    this.listFiles(sftp, remoteFolder).then((function(_this) {
      return function(files) {
        var filteredFiles, regex;
        _this.logger.debug(files, 'List of files');
        regex = new RegExp(fileRegex);
        filteredFiles = _.filter(files, function(f) {
          switch (f.filename) {
            case '.':
            case '..':
              return false;
            default:
              return regex.test(f.filename);
          }
        });
        return Q.all(_.map(filteredFiles, function(f) {
          return _this.stats(sftp, "" + remoteFolder + "/" + f.filename);
        })).then(function(stats) {
          var filesOnly;
          filesOnly = [];
          _.each(filteredFiles, function(f, i) {
            if (stats[i].isFile()) {
              return filesOnly.push(f);
            }
          });
          _this.logger.debug(filesOnly, "About to download");
          return Q.all(_.map(filesOnly, function(f) {
            return _this.getFile(sftp, "" + remoteFolder + "/" + f.filename, "" + tmpFolder + "/" + f.filename);
          }));
        }).then(function() {
          return deferred.resolve();
        });
      };
    })(this)).fail(function(error) {
      return deferred.reject(error);
    });
    return deferred.promise;
  };

  return Sftp;

})();

module.exports = Sftp;
